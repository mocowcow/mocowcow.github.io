---
layout      : single
title       : LeetCode 3139. Minimum Cost to Equalize Array
tags        : LeetCode
---
周賽 396。小小吐槽一下，答案好像沒必要模 10^9 + 7。  

## 題目

輸入整數字串 nums 和兩個整數 cost1, cost2。  
你可以執行以下兩種操作**任意次**：

- 選擇索引 i，以成本為 cost1 將 nums[i] 增加 1  
- 選擇不同的索引 i, j，以成本為 cost2 將 nums[i], nums[j] 都增加 1  

求使得陣列中所有元素相同的**最小成本**。  

答案可能很大，先模 10^9 + 7 後回傳。  

## 解法

操作一選一個數，操作二選兩個數。  
先考慮特殊情況：

- N = 1，只能用操作一  
- N = 2，操作二沒意義，也只能用操作一  
- cost1 \* 2 <= cost2，只用操作一更省錢  

除此之外的一般情況，則優先使用操作二，剩下的才使用操作一。

---

本題的操作都只能把值增加，要把所有元素都變成目標值 T。  
對於 nums 中每個元素 x，各需 T - x 次操作。將各元素所需操作次數記做陣列 diff。  

問題等價轉換成：  
> 有 N 種不同顏色的石頭，每個顏色的數量為 diff[i]  
> 每次可以挑**兩個不同顏色**的石頭一組，最多能挑幾組  
> 組數就是操作二，剩下的石頭就是操作一  

設 T = max(diff), S = sum(diff)。分類討論以下情況：  

- S - T >= T  
    可以選 S / 2 組  
  - 若 S 是偶數，剩下 0 個石頭  
  - 若 S 是奇數，剩下 1 個石頭  
- S - T < T  
    可以選 S - T 組，剩下 S - (S - T) \* 2 個石頭  

按照公式代入 cost，大概會變成這樣子。  

```python
def f(T, S): 
    if S - T >= T:
        op1 = S % 2
        op2 = S // 2
    else: # S - T < T
        op1 = S - (S - T) * 2
        op2 = S - T
    return cost1 * op1 + cost2 * op2
```
