---
layout      : single
title       : LeetCode 3165. Maximum Sum of Subsequence With Non-adjacent Elements
tags        : LeetCode
---
周賽 399。連續兩場都出線段樹，太狠了。  

## 題目

輸入整數陣列 nums。
還有二維整數陣列 queries，其中 queries[i] = [pos<sub>i</sub> , x<sub>i</sub>]。  

對於第 i 個查詢，首先將 nums[pos<sub>i</sub>] 設為 x<sub>i</sub>，然後計算 nums 中**不含相鄰元素**的**子序列**的**最大和**。  

回傳所有查詢結果的加總。  
答案可能很大，先模 10^9 + 7 後回傳。  

## 解法

[198. house robber]({% post_url 2022-02-07-leetcode-198-house-robber %}) 的進化版本。  

在原始版本的問題中，dp(i) 代表的是子陣列 nums[0..i] 的最大利潤。  
假如更改了 nums[i] 的值，那麼從所有包含 nums[i] 的子陣列結果可能被改變。改變 nums[i] 最差情況下，需要重新計算 O(N) 次。  

---

既然說包含 nums[i] 的狀態要被重新計算，那沒包含的狀態不是就可以複用？沒錯。  
這給出一個靈感：將已經計算過的狀態**合併**計算出新的狀態。  

考慮有兩個獨立的陣列 A = [1,0,1], B = [0,3,0]，最大和 = 2, 3。  
不難看出兩陣列合併後 [1,0,1,0,3,0] 最大和 = 2 + 3。但只是巧合。  

考慮另一個例子 A = [1,0,1], B =[3,0,3]，最大和 = 2, 6。  
但很明顯連接邊界的兩個元素不能都選，只能最多擇一。  
枚舉放棄哪邊，合併的結果有兩種可能：  

- 情形 1  
    A 保留右邊元素，保持完整；B 放棄左邊元素，左開右閉。  
    [1,0,1] + [0,3] 最大和 = 2 + 3 = 5  

- 情形 2  
    A 放棄右邊元素，左閉右開；B 保留左邊元素，保持完整。  
    [1,0] + [3,0,3] 最大和 = 1 + 6 = 7  

完整的閉區間，需要參考到子區間的半閉狀態轉移而來。  
所以每個子區間都需要維護**閉區間** [L,R]、**左閉右開** [L,R)、**左開右閉** (L,R] 三種狀態，供合併使用。  
這三種狀態分辨以 f11, f10, f01 表示，其中 0/1 代表邊界元素能不能選。  
