---
layout      : single
title       : LeetCode 2945. Find Maximum Non-decreasing Array Length
tags        : LeetCode
---
雙周賽118。我連怎麼下手都不知道，最後不到50個人做出來的樣子，有機會刷新全站最高難度。  

題外話，本題似乎是amazon辦的某個比賽的原題，然侯第一個做出來的印度老哥正好是該公司員工，然後跟著就冒出一堆印度老哥也做出來了。  
這次前25名竟然有一半都是印度人，而且有兩個才1700分，連簡單的Q2都沒做出來，竟然能做出這題大概2800分的題，真有點意思。  

## 題目

輸入整數陣列nums。  

你可以執行任意次操作，每次操作可以從nums中選擇一個**子陣列**，並將其替換成元素和。  
例如[1,3,5,6]選擇子陣列[3,5]進行操作，得到[1,**8**,6]。  

求任意次操作後，使得陣列滿足**非遞減**條件下所能得到的**最大**長度。  

## 解法

搞好幾天才弄懂，感覺上有兩道門檻，光是要找到入口就有點難度。  

大佬說了一句話：  
> 貪心的盡頭是dp  

貪心是一種求局部最佳解的方式，而dp求的是全局最佳解。  
若剛好全局最佳解是由各個局部最佳所求出，那麼兩者都能夠找出答案；但有時局部最佳並無法構成全局最佳，這時候只能靠dp來解決。  
個人理解為，當**發現無法貪心**(局部最佳非全局最佳)時，應當及時回頭，改朝著dp去思考。  

從範例三可以看出，貪心的合併並不是最佳解，轉去想dp吧。  
定義dp[i]：以i結尾的子陣列，經過任意次合併後，滿足非遞減時的**最大長度**。  
從滿足j<i的索引j轉移過來，而nums[j+1,i]這串全部合併起來，結尾元素sum(nums[j+1,i])記做last[i]。  
轉移方程式：dp[i]=max(dp[j]+1 FOR ALL -1<=j<i)，且滿足last[j]<=last[i]  
base case：為了允許從空陣列轉移，使-1代表空陣列，dp[-1]和last[-1]都為0。  

在dp[i]最大化的前提下，last[i]應該越小越好，這樣更有利於之後接續的新元素。  
例如nums = [2,1,3,..]的情況，合成[3,3..]肯定是比[2,4,..]更有機會變長。  

到目前為止的步驟是：  

1. 枚舉結尾i  
2. 找到須滿足last[j]<=sum(nums[j+1,i])，且使dp[i]最大化，再使last[i]最小的轉移轉移來源j  

仔細想想，在我們枚舉i的過程中，需要合併的數不斷增加。但最差情況下也就是直接合併到最尾端的last[i-1]裡面去，得dp[i]=dp[i-1]，所以dp[i]一定是**非遞減**的。  
那對於同一個i來說，當轉移來源j越大，合併到i的數越少，last[i]也會更小。  
正向枚舉j的過程中，只要當前的j滿足last[j]<=sm，那麼他絕對不會比之前的dp[j]更差，然後last[i]一定會更小。  
至於求子陣列和可以用前綴和來優化，只要O(1)求和。  

時間複雜度O(N^2)。  
空間複雜度O(N)。  

```python
class Solution:
    def findMaximumLength(self, nums: List[int]) -> int:
        N=len(nums)
        ps=list(accumulate(nums))+[0]
        dp=[0]*(N+1)
        last=[0]*(N+1)
        
        # O(N^2) TLE
        for i,x in enumerate(nums):
            for j in range(-1,i):
                sm=ps[i]-ps[j]
                if last[j]<=sm:
                    dp[i]=dp[j]+1
                    last[i]=sm
                    
        return dp[N-1]
```
